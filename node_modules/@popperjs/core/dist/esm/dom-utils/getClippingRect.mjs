import { viewport } from "../enums.mjs";
import getViewportRect from "./getViewportRect.mjs";
import getDocumentRect from "./getDocumentRect.mjs";
import listClippingParents from "./listClippingParents.mjs";
import getOffsetParent from "./getOffsetParent.mjs";
import getDocumentElement from "./getDocumentElement.mjs";
import getComputedStyle from "./getComputedStyle.mjs";
import { isElement, isHTMLElement } from "./instanceOf.mjs";
import getBoundingClientRect from "./getBoundingClientRect.mjs";
import getDecorations from "./getDecorations.mjs";
import contains from "./contains.mjs";
import rectToClientRect from "../utils/rectToClientRect.mjs";
import getFreshSideObject from "../utils/getFreshSideObject.mjs";

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = listClippingParents(element);
  var canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle(element).position);
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

  if (!isElement(clipperElement)) {
    return [];
  }

  return clippingParents.filter(function (clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement);
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


export default function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    var decorations = isHTMLElement(clippingParent) ? getDecorations(clippingParent) : getFreshSideObject();
    accRect.top = Math.max(rect.top + decorations.top, accRect.top);
    accRect.right = Math.min(rect.right - decorations.right, accRect.right);
    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);
    accRect.left = Math.max(rect.left + decorations.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}